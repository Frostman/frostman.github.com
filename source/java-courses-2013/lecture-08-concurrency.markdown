---                                                                                                                     
layout: page                                                                                                            
title: JC13 - Lecture 08. Concurrency basics                                                                                                                  
comments: false                                                                                                         
sharing: false                                                                                                          
sidebar: collapse
footer: false                                                                                                           
---
## [Mirantis](http://www.mirantis.com) Java Course 2013 ([back](index.html))
## Lecture 08. Concurrency basics

## План / тезисы

Писать корректно работающие приложения тяжело. 
Писать корректно работающие многопоточные приложения значительно сложнее. 

### Зачем нужна многопоточность?
* увеличение утилизации ресурсов;  
* растет число ядер, а не их частота;
* асинхронность; 
* отзывчивость интерфейсов; 
* распараллеливание разных ресурсов (io и cpu или net и cpu).

### Проблемы

* сложно тестировать;
* синхронизация;
* специфичные проблемы (deadlocks, livelocks, data races);
* safety hazards (non-thread-safe sequence generator).

### Работа с многопоточностью

* заложена в спецификации языка Java;
* синтаксические конструкции;
* четко определённая семантика;
* пакет `java.util.concurent`;

### Работа с потоками

* как создать и запустить поток;
* потоки-демоны;
* приоритеты потоков, перезапуск потоков;
* как получить ссылку на текущий поток;
* остановка и приостановка потоков deprecated;
* состояния потоков (NEW, RUNNABLE, BLOCKED, WAITING, TIMED_WAITING, TERMINATED);
* ключевое слово `synchronized` на метод/блок/статик метод, при этом происходит захват монитора;
* методы `Thread.sleep()`, `Thread.yield()`,  `Thread#join()`, `Thread.interrupt()`;
* ключевое слово `volatile`;
* `synchronized` и `volatile` также нужны чтобы потоки могли видеть изменения сделанные другими потоками (синхронизацию нельзя использовать только для записи);
* методы `Object#wait()`, `Object#notify()`, `Object#notifyAll()`, при вызове `notify()` просыпается случайный поток, при вызове `wait()` отпускается монитор, захваченный текущим потоком, при вызове `sleep()` и `join()` – нет;
* `IllegalMonitorStateException` при вызове вышеперечисленных методов у объекта, чьим монитором мы не владеем;
* случайные пробуждения (Spurious wakeup), поэтому метод `wait()` нужно звать только в цикле с проверкой условия;
* `InterruptedException`. Просьба прервать поток;
* Deadlocks;
* разница `StringBuffer` / `StringBuilder`, `Vector` / `ArrayList`.


## Практической задание #1 (сделать на занятии)
 
 Необходимо реализовать "mutex" с использованием механизма wait-notify.

 ```java
 public class Mutex {
     public Mutex() {...}

     public void acquire() throws java.lang.InterruptedException {...}
     public boolean tryAcquire() {...}
     public void release() throws InterruptedException {...}
                         
 }
 ```

 Метод `acquire` должен блокировать mutex если он свободен, а если он уже заболкирован, то ждать его освобождения.
 Метод `tryAcquire` должен блокировать mutex если он свободен, возвращая `true` или возвращать `false` если он уже заболкирован.
## Домашнее задание

### Практической задание #2 (сделать на занятии)

Ваша задача заключается в создании двух реализаций интерфейса `Task`:

Первая реализация - `SimpleTask` должна иметь следующий вид:

 ```java
 import java.util.concurrent.Callable;

 public final class SimpleTask<T> {
     // ...
     public SimpleTask(Callable<? extends T> callable) {
     // ...
     }

     public T get() throws MyException {
     // ...
     }
 }
```

Метод `get()` должен возвращать результат выполнения `callable` или бросать обернутое исключение,
произошедшее во время выполнения. Если при вызове get() результат уже просчитан, то он должен вернуться сразу. 
Вычисление значения (выполнение `callable`) должно происходить только один раз - в конструкторе.
`Callable` похож на `Runnuble`, но результатом его работы является объект (а не `void`). 

Далее необходимо реализовать лениво вычисляющийся `LazyTask`, имеющий такой же вид как и `SimpleTask`,
но вычисление значения (выполнение `callable`) должно происходить только при первом обращении к `get()`
(в потоке который совершил первый вызов и только один раз).
   


*Note.* Все решения должны быть thread-safe.

*Note.* Решения нужно присылать на nkonovalov@mirantis.com

### Задание #1 

Доделать практическое задание с занятия.

### Задание #2

Второе задание теоретическое. Ответ на каждый вопрос должен занимать 1-3 предложения. 

1. Как получить ссылку на текущий поток?
2. Зачем нужно ключевое слово `synchronized`? На что его можно повесить (поле, метод, класс, конструктор и тд)?
3. Захват какого монитора происходит при входе в `synchronized` метод / статический метод / блок кода?
4. Зачем нужно ключевое слово `volatile`? На что его можно повесить (поле, метод, класс, конструктор и тд)?
5. Что делают методы `Object#wait()`, `Object#notify()`, `Object#notifyAll()`?
6. Когда бросается исключение `IllegalMonitorStateException`?
7. Что делает метод `Thread#join()`?
8. Что делает метод `Thread#interrupt()`?

### Задание #3 

Ваша задача реализовать интерфейс `ExecutionManager`: 

 ```java
 public interface ExecutionManager {
     Context execute(Runnable callback, Runnable... tasks);
 }
 ```

Метод `execute()` принимает массив tasks, это задания которые `ExecutionManager` должен выполнять параллельно
(в вашей реализации это должно происходить в своем пуле потоков). 
После завершения исполнения всех заданий должен выполниться `callback` (ровно 1 раз). 

Метод `execute()` – это неблокирующий метод, который сразу возвращает объект `Context`.
`Context` - это интерфейс следующего вида: 

 ```java
 public interface Context {
     int getCompletedTaskCount(); 
     int getFailedTaskCount(); 
     int getInterruptedTaskCount(); 
     void interrupt(); 
     boolean isFinished(); 
 }
 ```
Описание поведения методов:

* `getCompletedTaskCount()` должен возвращать количество заданий, которые на текущий момент успешно выполнились;
* `getFailedTaskCount()` должен возвращать количество заданий, при выполнении которых было выброшено исключение; 
* `interrupt()` должен отменять выполнения заданий, которые еще не начали выполняться;
* `getInterruptedTaskCount()` должен возвращать количество заданий, которые не были выполены из-за отмены (вызовом предыдущего метода); 
* `isFinished()` должен возвращать `true`, если все таски были выполнены или отменены, `false` в противном случае.  
