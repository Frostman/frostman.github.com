---                                                                                                                     
layout: page                                                                                                            
title:                                                                                                                  
comments: false                                                                                                         
sharing: false                                                                                                          
sidebar: collapse
footer: false                                                                                                           
---
## Mirantis Java advanced course 2012 ([back](index.html))
## Lecture 01. Concurrency basics

## План / тезисы

Писать корректно работающие приложения тяжело. 
Писать корректно работающие многопоточные приложения значительно сложнее. 
Поглядеть на введение в конкарренси ин практиз.

### Зачем нужна многопоточность?
* увеличение утилизации ресурсов;  
* растет число ядер, а не их частота;
* асинхронность; 
* отзывчивость интерфейсов; 
* распараллеливание разных ресурсов (io и cpu или net и cpu).

### Проблемы

* сложно тестировать;
* синхронизация;
* специфичные проблемы (deadlocks, livelocks, data races);
* safety hazards (non-thread-safe sequence generator).

### Работа с многопоточностью

* заложена в спецификации языка Java;
* синтаксические конструкции;
* четко определённая семантика;
* пакет `java.util.concurent`;
* спецификация Java Memory Model, которая описывает, при каких условиях поток увидит изменения сделанные другим потоком.

### Работа с потоками

* как создать и запустить поток;
* потоки-демоны;
* приоритеты потоков, перезапуск потоков;
* как получить ссылку на текущий поток;
* остановка и приостановка потоков deprecated;
* состояния потоков (NEW, RUNNABLE, BLOCKED, WAITING, TIMED_WAITING, TERMINATED);
* ключевое слово `synchronized` на метод/блок/статик метод, при этом происходит захват монитора (монитор неявно ассоциируется со всеми объектами);
* методы `Thread.sleep()`, `Thread.yield()`,  `Thread#join()`;
* ключевое слово `volatile`;
* `synchronized` и `volatile` также нужны чтобы потоки могли видеть изменения сделанные другими потоками (необходимо для дз, также рассказать про скорость выполнения volatile read на x86).  Поэтому синхронизацию нельзя использовать только для записи;
* методы `Object#wait()`, `Object#notify()`, `Object#notifyAll()`. При вызове `notify()` просыпается случайный поток. При вызове `wait()` отпускается монитор, захваченный текущим потоком, при вызове `sleep()` и `join()` – нет;
* `IllegalMonitorStateException` при вызове вышеперечисленных методов у объекта, чьим монитором мы не владеем;
* случайные пробуждения (Spurious wakeup).  Поэтому метод `wait()` нужно звать только в цикле с проверкой условия;
* `InterruptedException`. Просьба прервать поток;
* Deadlocks;
* разница `StringBuffer` / `StringBuilder`, `Vector` / `ArrayList`.

Может быть стоит рассказать студентам про `ForkJoinPool` в кратце. например на втором занятие в конце и дать задание. Можно попробовать дать задачку на распараллеливание типа проверки правильности скобочной последовательности.

## Практической задание (сделать на занятии)
 
Реализовать: семафор, барьер, пул потоков.

## Домашнее задание

*Note.* Все решения должны быть thread-safe. 

### Задание #1

Первое задание теоретическое. Ответ на каждый вопрос должен занимать 1-2 предложения. 

1. Как получить ссылку на текущий поток?
2. Зачем нужно ключевое слово `synchronized`? На что его можно повесить (поле, метод, класс, конструктор и тд)?
3. Захват какого монитора происходит при входе в `synchronized` метод / статический метод / блок кода?
4. Зачем нужно ключевое слово `volatile`? На что его можно повесить (поле, метод, класс, конструктор и тд)?
5. Что делают методы `Object#wait()`, `Object#notify()`, `Object#notifyAll()`?
6. Когда бросается исключение `IllegalMonitorStateException`?
7. Что делает метод `Thread#join()`?
8. Что делает метод `Thread#interrupt()`?

Мб стоит использовать google forms для сбора ответов для удобства.

### Задание #2 

Ваша задача заключается в создании двух реализаций интерфейса `Task`:

```java
public interface Task<T> {
    T get() throws MyException;
}
```

Замените название `MyException` на более подходящее. В это исключение должны оборачиваться исключения 
(в любой из реализаций интерфейса `Task`), возникшие во время исполнения задачи, 
и оно должно быть выброшено всем потокам, которые вызывают `get()`.

Первая реализация - `SimpleTask` должна иметь следующий вид:

```java
import java.util.concurrent.Callable;

public final class SimpleTask<T> implements Task<T> {
    // ...

    public SimpleTask(Callable<? extends T> callable) {
        // ...
    }
    
    public T get() throws MyException {
        // ...
    }
}
```

Метод `get()` должен возвращать результат выполнения `callable` или бросать обернутое исключение,
произошедшее во время выполнения. Если при вызове get() результат уже просчитан, то он должен вернуться сразу
(даже без задержек на вход в синхронизированную область, справедливо для всех реализаций). 
Вычисление значения (выполнение `callable`) должно происходить только один раз - в конструкторе.
`Callable` похож на `Runnuble`, но результатом его работы является объект (а не `void`). 

Далее необходимо реализовать лениво вычисляющийся `LazyTask`, имеющий такой же вид как и `SimpleTask`,
но вычисление значения (выполнение `callable`) должно происходить только при первом обращении к `get()`
(в потоке который совершил первый вызов и только один раз).
   

### Задание #3 
Ваша задача реализовать интерфейс `ExecutionManager`: 

```java
public interface ExecutionManager {
    Context execute(Runnable callback, Runnable... tasks);
}
```

Метод `execute()` принимает массив tasks, это задания которые `ExecutionManager` должен выполнять параллельно
(в вашей реализации это должно происходить в своем пуле потоков). 
После завершения исполнения всех заданий должен выполниться `callback` (ровно 1 раз). 

Метод `execute()` – это неблокирующий метод, который сразу возвращает объект `Context`.
`Context` - это интерфейс следующего вида: 

```java
public interface Context {
    int getCompletedTaskCount(); 
    int getFailedTaskCount(); 
    int getInterruptedTaskCount(); 
    void interrupt(); 
    boolean isFinished(); 
}
```
Описание поведения методов:

* `getCompletedTaskCount()` должен возвращать количество заданий, которые на текущий момент успешно выполнились;
* `getFailedTaskCount()` должен возвращать количество заданий, при выполнении которых было выброшено исключение; 
* `interrupt()` должен отменять выполнения заданий, которые еще не начали выполняться;
* `getInterruptedTaskCount()` должен возвращать количество заданий, которые не были выполены из-за отмены (вызовом предыдущего метода); 
* `isFinished()` должен возвращать `true`, если все таски были выполнены или отменены, `false` в противном случае.  

Далее можно развить и/или объединить эти задания чтобы они стали частью следующего задания.

## Общие мысли по практических занятиям.

* гит репозиторий для каждого задания (бранчи) с заготовками (интерфейсами и тестами)
* задания сдавать в виде ссылок на репозиторий на гитхабе (посоветоваться с Герой)
* обязательно использовать мавен
